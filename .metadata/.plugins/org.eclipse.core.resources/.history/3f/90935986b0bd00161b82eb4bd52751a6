package model.player;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;

import model.Observer;
import model.EnumType.EnumOrigineCA;
import model.EnumType.EnumOrigineDivinite;
import model.cards.ActionCard;
import model.cards.Card;
import model.cards.Divinity;
import model.game.De;
import model.game.GameManager;

/**Classe qui repr√©sente un joueur*/
public abstract class Player extends Observer{

	//A voir si chaque joueur a un tableau de Points d'action
	// ou si on fait un tableau pour chaque type de point d'action
	//ou un seul tableau de taille 3 avec en indice 0 les points de jour, indice 1 les points de nuit, indice 2 les points de neant, 
	
	public static final int NB_CARTE_MAX = 7;
	
	/**cha√Æne de caract√®re repr√©sebtant le nom du joueur*/
	private String pseudo;
	
	/**Entier repr√©sentant le nombre de croyant que possede le joueur*/
	protected int score;
	
	private int age;
	
	/**Liste repr√©sentant la main d'un joueur*/ 
	protected LinkedList<Card> hand = new LinkedList<Card>();
	
	/**Dictionnaire contenant les points d'action du joueur*/
	private HashMap<EnumOrigineCA, Integer> dicoPA = new HashMap<EnumOrigineCA, Integer>();
	
	/**Carte divint√© du joueur*/
	private Divinity divinity;
	
	/**Attribut repr√©sentant la liste des joueurs*/
	////////////////////////////////////////////Faire en sorte que cette liste soit cr√©er en fonction du nombre de joueur d√©finie par l'utilisateur*/
	public final static String[] NOM = {"Joueur1","Joueur2","Joueur3","Joueur4","Joueur5","Joueur6","Joueur7","Joueur8","Joueur9","Joueur10"};

	/**Constructeur public*/
	public Player(String pseudo, int age){
		this.setNom(pseudo);
		this.setAge(age);
		
		//Permet l'initialisation du dictionnaire de points d'action du joueur
		EnumOrigineCA valuesEnumPointAction[] = EnumOrigineCA.values();
		for (int i = 0; i< valuesEnumPointAction.length; i++) {
			dicoPA.put(valuesEnumPointAction[i], 0);
		}
	}
	
	//MÈthode de jeu de tour qui se fait redÈfinir pour le joueur et le bot
	public abstract void jouerTour();
	
	
	/** Le joueur joue une carte et donc on l'enleve de sa main*/
	public void JouerCarte(int carte) {
		hand.remove(carte);
	}
	
	/**Methode piocher*/
	public void piocher(){
		hand.add(GameManager.getInstanceUniqueManager().piocherCarte());
    }
	
	//Permet au joueur de piocher sa divinite
	public void piocherDivinite(){
		this.divinity = GameManager.getInstanceUniqueManager().piocherDivinite();
	}
	
	//////////////////////////////// GETTERS & SETTERS////////////////////////////////////////////////
	
	public static Object deepClone(Object object) {
		   try {
		     ByteArrayOutputStream baos = new ByteArrayOutputStream();
		     ObjectOutputStream oos = new ObjectOutputStream(baos);
		     oos.writeObject(object);
		     ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
		     ObjectInputStream ois = new ObjectInputStream(bais);
		     return ois.readObject();
		   }
		   catch (Exception e) {
		     e.printStackTrace();
		     return null;
		   }
	}
	
	
	//Permet de renvoyer une liste 
	public List<Card> getHand(){ 
		return Collections.unmodifiableList(hand);
	}
	
	/**Getter du pseudo*/
	public String getNom(){
		return pseudo;
	}
	/**Setter du pseudo*/
	public void setNom(String pseudo){
		this.pseudo = pseudo;
	}
	/**Getter du score du joueur*/
	public int getScore() {
		return score;
	}
	/**Setter du score du joueur*/
	public void setScore(int score) {
		this.score = score;
	}

	/**Getter de la divinit√© du joueur*/
	public Divinity getDivinity() {
		return divinity;
	}
	/**Setter de la divinit√© du joueur*/
	public void setDivinity(Divinity divinity) {
		this.divinity = divinity;
	}

	public int getAge() {
		return age;
	}

	private void setAge(int age) {
		this.age = age;
	}
	
	public void lancerDe(){
		De.getInstanceDe().lancerDe();
	}
	
	public void defausserCartes(LinkedList<ActionCard> cartes){
		hand.removeAll(cartes);
		GameManager.getInstanceUniqueManager().defausserCarte(cartes);
	}
	
	//Fonction permettant de complÈter la main du joueur
	public void piocherCartes(){
		while (hand.size() <= NB_CARTE_MAX){
			GameManager.getInstanceUniqueManager().piocherCarte();
		}
	}
	
	public int getNbCartes(){
		return hand.size();
	}
	
	public void decrementerPointAction(EnumOrigineCA typePA, int nbPA){
		if ((dicoPA.get(typePA) - nbPA) < 0){
			//lancer Exception, le joueur ne peut pas jouer la carte
		}
		dicoPA.replace(typePA, dicoPA.get(typePA), dicoPA.get(typePA) - nbPA);
	}
	
	//MÈthode appelÈe ‡ chaque dÈbut de tour pour attribuer les PA au joueur
	protected void incrementerPointActionWithDe(){
		
		if (divinity.getOrigine() == EnumOrigineDivinite.AUBE || divinity.getOrigine() == EnumOrigineDivinite.CREPUSCULE){
			if(De.getInstanceDe().getFace() == EnumOrigineCA.NEANT){
				dicoPA.put(EnumOrigineCA.NEANT, dicoPA.get(EnumOrigineCA.NEANT) +1);
			}else{
				dicoPA.put(De.getInstanceDe().getFace(), dicoPA.get(De.getInstanceDe().getFace()) +1);
			}
		}else{
			if (De.getInstanceDe().getFace() == EnumOrigineCA.JOUR || De.getInstanceDe().getFace() == EnumOrigineCA.NUIT){
				dicoPA.put(De.getInstanceDe().getFace(), dicoPA.get(De.getInstanceDe().getFace()) +2);
			}
		}
	}
	

	public void incrementerPointAction(EnumOrigineCA typePA, int nbPA){
		dicoPA.replace(typePA, dicoPA.get(typePA), dicoPA.get(typePA) + nbPA);
	}
	
	@Override
	public String toString() {
		return "Player [pseudo=" + pseudo +", dicoPA="+ dicoPA;
		
		/*
		return "Player [pseudo=" + pseudo + ", score=" + score + ", age=" + age + ", hand=" + hand + ", dicoPA="
				+ dicoPA + ", divinity=" + divinity + "]";
				*/
	}
}


